# 1장 깨끗한 코드
`written by 문다빈`

> 여러분이 이 책을 읽고 있다면 이유는 두 가지다. 첫째, 프로그래머라서. 둘째, 더 나은 프로그래머가 되려고. 다행이다! **우리 업계는 더 나은 프로그래머가 필요하니까.**
> 

## 0. 읽으면서 느낀점

최근 스터디때문에 클린 아키텍쳐를 읽기 시작했는데, 그김에 겸사겸사 클린 코드도 읽기 시작했다.(~~저자가 같으니까..ㅋㅋ~~) 클린 아키텍쳐에서도 느꼈지만, 로버트 C. 마틴은 책의 도입부에서 왜 내가 클린 코드를 공부해야 되고, 클린 코드를 적용해야 하는지 동기부여를 확실하게 해주는 것 같다. 솔직히 좀 극단적인 예시가 없지않아 있다고 해도.. 정말 명문이 많다. 1장에 특히 그런 동기부여 관련 내용이 많은데, 솔직히 **이 내용은 개발자 말고 비개발자 직군에서 읽으면 더더더 좋을 것 같긴하다.

**”개발자는 도구가 아니다”**

나 조차도 점점 상업적 프로젝트에 익숙해져서 도구화(?)가 이뤄지고 있는 현재 시점에, 책을 읽으면서 가장 크게 느꼈던 것은 주도적인 개발자가 되는 것이 중요하다는 것이었다. 여기서 주도적인 개발자라는 것은 단순히 기능 구현을 잘하는 개발자(사실 오히려 이 쪽은 도구(?)쪽에 더 가깝다는 생각이 든다.)가 아니고, **프로젝트에서 개발자만이 알 수 있는 지식을 바탕으로 클린 코드를 지키는 개발자**라고 말하고 싶다. 해외는 어떨지 모르지만, 적어도 국내 IT 업계에선.. 많은 개발자들이 처음엔 야심차게 프로젝트를 시작했다가, 갈수록 시간에 쫓겨 이게 코드인지 스파게티인지 분간이 되지 않을 코드를 많이 짜게 되는 것 같다.
<img src ="https://file.notion.so/f/s/cbdef472-0190-4ef8-b0be-cd0e052eb18d/KakaoTalk_Photo_2023-05-06-21-23-58.jpeg?id=87646118-191a-4d3e-8227-bd78a44f044c&table=block&spaceId=791e5689-e98d-4b2d-8794-8b0cb8b434cc&expirationTimestamp=1683464426316&signature=7cVwlEsubR9czH33SorhZnZ9I1oAhUYBEjfkUuJpaJ0&downloadName=KakaoTalk_Photo_2023-05-06-21-23-58.jpeg" width = 500>

**하나의 상황을 가정해보자.**
**기획자 :** “개발자님 말 한마리 만들어주세요. 기한은 2주일 뒤로 해주세요. 괜찮으신가요?”

<img src ="https://file.notion.so/f/s/a40d61ac-d9bb-404d-8519-e0565a613bde/Untitled.png?id=1b179b8f-6ead-4b66-8ff6-3b887b534843&table=block&spaceId=791e5689-e98d-4b2d-8794-8b0cb8b434cc&expirationTimestamp=1683464511106&signature=Bb8Opdom97ByO4LFzsWnp41ZFH5q8lGvfIptrSdOkIU&downloadName=Untitled.png" width = 500>

**개발자 :** “넵(열심히 설계를 한다)”

```kotlin
class horse(
   val color,
   val size,
)
```

**그렇게 일주일 뒤..**

**기획자 :** “개발자님 제가 기획서에 빠뜨려서 그런데, 말이라면 시속 88km로 달려야되고, 수명은 30년으로 잡아주셔야 됩니다. **원래 말들이 그러니까 사용자들도 그걸 당연히 기대할 거구요.** 그리고 우리 회사 말은 서러브레드 였으면 좋겠는데, 해당 사항 추가해서 다음주까지 완료해주실 수 있을까요? 회사 일정이 그렇게 잡혀서 미룰 수는 없을 것 같아요.”

**개발자 :** “넵(열심히 설계한 걸 뒤엎는다)”

```kotlin
class Thoroughbred(
   val color,
   val size,
   val life,
   val speed 
)
```

**릴리즈 이후**

**기획자 :** “개발자님 이번 업데이트 때는 회사에서 유니콘을 추가하기로 했어요! 기존 서러브레드랑 달리 유니콘은 수명도 없게 해주시면 좋겠고, 뿔이랑 날개도 추가해주시면 좋을 것 같아요. 아 그리고, 말 종류도 기존 서러브레드에서 좀 더 추가해주시면 좋겠어요. **저번에 말은 만드셨으니까 여기서 조금만 기능 추가해도 금방 완성될 것 같은데, 일주일내로 작업 완료 가능하신가요?**”

<img src = "https://file.notion.so/f/s/472ed0f3-8376-4fa7-a258-be50191d2605/Untitled.png?id=7d1b967f-d811-4620-b0e3-bf88bedc78ef&table=block&spaceId=791e5689-e98d-4b2d-8794-8b0cb8b434cc&expirationTimestamp=1683464581382&signature=19cim5d8T-Zc-Yeb1vj96U6lNBI6c98Pt6NNQW7iJHs&downloadName=Untitled.png" width = 500>

**개발자 :** “…”
(예시 코드가 너무 극단적이긴하지만 흐린눈 해주세요..)

<img src = "https://file.notion.so/f/s/3bedb383-91fd-4978-9650-408fd73e79a1/Untitled.png?id=0ec48241-ce93-4bdd-8732-680c811a4e54&table=block&spaceId=791e5689-e98d-4b2d-8794-8b0cb8b434cc&expirationTimestamp=1683464663174&signature=A0ZSZXubI25ND4dMGOfswKRiQJ9zxJdNOzgSIitOBtM&downloadName=Untitled.png" width = 300>

사실 진짜 일 잘하는 개발자는.. 안 된다고 말할 줄 아는 개발자가 아닐까? 우리는 코드를 지킬 의무가 있으니까, 무조건적인 수용은 사실 독이 될 수밖에 없다. 당장엔 개발자만 손해보는 느낌이어도 장기적으로 봤을때는 프로젝트 전체가 **나쁜 코드**로인해 병들게 될 것이다.  

**”깨진 창문은 정말로 돌아보기도 싫더라..”**

여러가지 사이드 프로젝트를 진행하고 끝내면서 느꼈던 점은.. **시간에 쫓겨 프로젝트 코드를 망가뜨리고 릴리즈한 프로젝트의 경우 정말 꼴도보기 싫다는 것이다.** 그렇다고 근본부터 뜯어고치기엔 시간(~~사람~~)은 우릴 기다려 주지않는다. 그래서 결국 우리는 처음에 짤 때부터 최대한 코드를 깨끗하게 짜는 습관을 가져야한다. ~~그래야 모두가 고통받지 않으니까..~~ 사실 최신 기술을 익히는 것보다도.. 이러한 습관을 가지는게 가장 어렵다고 생각한다. 처음에는 누구나 야심차게 이번엔 코드를 예쁘게 짜보자! 다짐 하지만.. 시간에 쫓기면 다 무용지물이다. 나 또한 약한 부분이 이런 부분이라서.. 이번 클린 코드 책을 읽으면서 **제한된 시간에 내 능력선에서 최대한 깔끔한 코드를 짜는 법을** 배우고싶다. 지나간 코드는 다시 돌아볼 시간이 없으니까 말이다.

---

## 1. 코드가 존재하리라

- 코드의 종말이 코앞에 닥쳤다고 주장하는 사람이 없지않다.
    - **Why?**
        1. 코드를 자동으로 생성하는 시대가 온다. → 그때가 되면 프로그래머는 필요 없다.
        2. 그때가 되면 영업 직원이 명세에서 프로그램을 자동으로 생성하면 된다.
- 하지만 이러한 주장은 터무니 없다.
    - **Why?**
        1. 코드는 요구사항을 상세히 표현하는 수단이다. → 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하게 표현하기란 불가능하다.
        2. 추상화가 불가능하다.
- 기계가 실행될 수 있을 정도로 상세하게 요구사항을 명시하는 작업, 이것이 바로 **프로그래밍**이다.
    - 명시한 결과가 바로 코드이다.
- 어떤 언어를 사용하든, 코드는 기계가 이해하고 실행할 정도로 엄밀하고 정확하고 상세하고 정형화되어야 한다.
- 요구사항을 모호하게 줘도 우리 의도를 정확히 꿰뚫어 프로그램을 완벽하게 실행하는 기계가 생성되길 기대하지만 이러한 기대는 불가능한 기대이다.
    - **Why?**
        1. 창의력과 직관을 보유한 우리 인간조차도 고객의 막연한 감정만 갖고는 성공적인 시스템을 구현하지 못한다.
        2. **제대로 명시한 요구사항은 코드만큼 정형적이며 테스트 케이스로 사용해도 좋다.**
        3. 코드는 요구사항을 표현하는 언어이다. → 요구사항에 더욱 가까운 언어를 만들 수도 있고, 요구사항에서 정형 구조를 뽑아내는 도구를 만들 수도 있다.
        4. 하지만 어느 순간에도 정밀한 표현이 필요하고, 그 필요성을 없앨 방법은 없다.

---

## 2. 나쁜 코드

- **좋은 코드는 중요하다.**
- 출시에 **바빠 코드를 마구 짜게 되면, 기능을 추가할수록 코드가 엉망이 되어가고, 결국은 감당이 불가능한 수준에 이른다.**
- 즉 프로젝트가 망한 원인은 바로 **나쁜 코드** 탓이다.
- 나쁜 코드에 발목을 잡힌다. → **고행(wading)**
- 왜 나쁜 코드를 짜는가? → 급해서 서두르느라 그랬을 것이다.
- 개발자는 **대개 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험**이 있다.
- 개발자는 **대충 짠 프로그램이 돌아간다는 사실에 안도감을 느끼며 그래도 안 돌아가는 프로그램보다 돌아가는 쓰레기가 좋다고 스스로를 위로한 경험**이 있다.
- 다시 돌아와 나중에 정리하겠다고 다짐하지만, 나중은 결코 오지 않는다. → **르블랑의 법칙**

---

## 3. 나쁜 코드로 치르는 대가

- 2~3년 넘게 프로그램을 짰다면 남들이 저질러놓은 쓰레기 코드로 고생한 경험이 있을 것이다.
- 코드가 하도 엉망이라 프로젝트 진도가 안 나가는 경험도 있을 것이다.
- 나쁜 코드는 개발 속도를 크게 떨어뜨린다.
- 프로젝트 초반에는 번개처럼 나가다가 1-2년만에 굼뱅이처럼 기어가는 팀도 많다.
- 코드를 고칠 때마다 엉뚱한 곳에서 문제가 생긴다.
- 매번 얽히고설킨 코드를 '해독'해서 얽히고설킨 코드를 더한다.
- **나쁜 코드가 쌓일수록 팀 생산성은 떨어진다.** → ****그러다가 마침내 0에 근접한다.
- 생산성이 떨어지면 관리층은 나름대로 복구를 시도한다 → 인력 추가 투입.
- 하지만 새 인력은 시스템 설계에 대한 조예가 깊지 않고, 설계 의도에 맞는 변경과 설계 의도에 반하는 변경을 구분하지 못한다.
- 새 인력과 팀은 생산성을 높여야 한다는 극심한 압력에 시달려, 결국 나쁜 코드를 더 많이 양산한다
- 생산성은 더더욱 떨어져 거의 0이 된다.

---

## 4. 원대한 재설계의 꿈

- 마침내 프로그래머 측에서 관리층에게 재설계를 요구하면, **관리층은 재설계에 자원을 쏟아붓기 싫지만** 생산성이 바닥이라는 사실을 부인할 도리가 없어 재설계를 허락한다
- 모두가 재설계를 담당하는 새로운 프로젝트 팀에 합류하고 싶어한다. → 처음부터 프로젝트를 시작해 진정으로 아름다운 작품을 창조할 기회니까.
- 하지만 가장 유능하고 똑똑한 사람들만 새로운 팀으로 차출되고, 나머지는 계속해서 현재 시스템을 유지보수한다.
- 새로운 팀은 기존 시스템 기능을 모두 제공하는 새 시스템을 내놓아야 하고, 그동안 기존 시스템에 가해지는 변경도 모두 따라잡아야 한다.
- 이러한 작업은 아주 오랫동안 이어져 10년이 넘게 걸리는 경우도 있다.
- 새 시스템이 기존 시스템을 따라잡을 즈음이면 초창기 팀원들은 모두 팀을 떠났고 **새로운 팀원들이 현재 시스템이 너무 엉망이라서 새 시스템을 설계하자고 나선다.**
- **결국 시간을 들여 깨끗한 코드를 만드는 노력이 비용을 절감하는 방법일 뿐만 아니라 전문가로서 살아남는 길이다.**

---

## 5. 태도

- 좋은 코드가 어째서 순식간에 나쁜 코드로 전락할까?
- 여기에 우리는 온갖 이유를 들이댄다.
    - 원래 설계를 뒤지는 방향으로 요구사항이 변했다고 불평한다.
    - 일정이 촉박해 제대로 할 시간이 없었다고 한탄한다.
- ❗**But..** **사실 잘못은 전적으로 우리 프로그래머에게 있다.** **→ 우리가 전문가답지 못했기 때문.**
    - 관리자는 개발자에게 정보를 구한다.
    - 관리자가 개발자에게 정보를 구하지 않더라도 우리가 적극적으로 정보를 제공해야 마땅하다.
    - 사용자는 요구사항을 내놓으며 우리에게 현실성을 자문한다.
    - 프로젝트 관리자는 일정을 잡으며 우리에게 도움을 청한다.
    - 우리는 프로젝트를 계획하는 과정에 깊숙히 관여한다. → **그러므로 프로젝트 실패는 우리에게도 커다란 책임이 있다.**
- 나쁜 코드가 초래하는 실패에는 더더욱 책임이 크다. → 일정에 쫓기더라도 대다수 관리자는 좋은 코드를 원한다.
- 관리자들이 일정과 요구사항을 강력하게 밀어붙이는 이유는 그것이 관리자들의 책임이기 때문.
- **좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다.**
- **프로그래머도 마찬가지다. 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.**

---

## 6. 원초적 난제

- 프로그래머라면 누구나 나쁜 코드가 업무 속도를 늦춘다는 사실을 익히 안다. → 그럼에도 모든 프로그래머가 기한을 맞추려면 나쁜 코드를 양산할 수밖에 없다고 느낀다.
- 그러나, 나쁜 코드를 양산하면 사실 기한을 맞추지 못한다. → 엉망진창인 상태로 인해 속도가 곧바로 늦어지고, 결국 기한을 놓친다.
- 기한을 맞추는 유일한 방법(== 빨리 작업하는 유일한 방법)은 코드를 최대한 깨끗하게 유지하는 습관이다.

---

## 7. 깨끗한 코드라는 예술?

- **“깨끗한 코드를 어떻게 작성할까?”**
    - 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 안다는 뜻은 아니다.
    - 깨끗한 코드를 작성하려면 '청결'이라는 힘겹게 습득한 감각을 활용해 자잘한 기법들을 적용하는 절제와 규율이 필요하다.
    - 키포인트는 **'코드 감각'**이다. → **재능의 영역이자, 노력으로 커버칠 수 있는 부분**
    - '코드 감각'이 있으면 좋은 코드와 나쁜 코드를 구분한다.
    - 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악한다.
    - '코드 감각'이 없는 프로그래머도 때로는 나쁜 모듈을 알아본다. → 하지만 거기서 더 나아가지 못한다.
    - '코드 감각'이 있는 프로그래머는 나쁜 모듈을 보면 좋은 모듈로 개선할 방안을 떠올린다

---

## 8. 깨끗한 코드란?

### **비야네 스트롭스트룹(C++ 창시자)**

> 우아하고 효율적인 코드를 좋아함.
논리가 간단해야 버그가 숨어들지 못함.
의존성을 최대한 줄여야 유지보수가 쉬워진다.
오류는 명백한 전략에 의거해 철저히 처리한다.
성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다.
깨끗한 코드는 한 가지를 제대로 한다.
> 
- 비야네는 '우아한'(보기에 즐거운)이란 단어를 사용한다.
- 깨끗한 코드는 '보기에 즐거운' 코드다. → 우아한 코드
- 깨끗한 코드는 보는 사람에게 즐거움을 선사해야한다.
- CPU 자원을 낭비하는 코드도 우아하지 못하다. → 보기에 즐겁지 못함.(+속도가 느린 코드도 우아하지 못하다.)
- 우아하지 않은 코드는 바람직하지 않은 결과를 초래한다. → 나쁜 코드는 나쁜 코드를 '유혹'한다.
- 실용주의 프로그래머 데이브 토마스와 앤디 헌트는 같은 이야기를 다르게 표현 → 그들은 **깨진 창문**이라는 비유를 사용
- **깨진 창문이란?**
    - 창문이 깨진 건물은 누구도 상관하지 않는다는 인상을 풍긴다.그래서 사람들도 관심을 끊는다. 창문이 더 깨져도 상관하지 않는다. 마침내는 자발적으로 창문을 깬다. 일단 창문이 깨지고 나면 쇠퇴하는 과정이 시작된다.
- 철저한 오류 처리
    - 세세한 사항까지 꼼꼼하게 신경 써야한다.
    - 메모리 누수, 경쟁 상태, 일관성 없는 명명법이 오류 처리의 예다.
    - 한 마디로 요약하면, 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드다.
- 깨끗한 코드란 한 가지를 잘 한다
    - 나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고 목적이 흐려진다.
    - 깨끗한 코드는 한가지에 '집중'한다.
    - 각 함수와 클래스와 모듈은 주변 상황에 현혹되거나 오염되지 않은 채 한길만 걷는다.

### **그래디 부치**

> 깨끗한 코드는 단순하고 직접적이다.
깨끗한 코드는 잘 쓴 문장처럼 읽힌다.
깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다.
오히려 명쾌한 추상화와 단순한 제어문으로 가득하다.
> 
- 그래디는 가독성을 강조한다.
- 코드는 추측이 아니라 사실에 기반해야 한다. 반드시 필요한 내용만 담아야 한다.
- 코드를 읽는 사람에게 프로그래머가 단호하다는 인상을 줘야 한다.

### **큰 데이브 토마스**

> 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.
단위 테스트 케이스와 인수 테스트 케이스가 존재한다.
깨끗한 코드에는 의미 있는 이름이 붙는다.
특정 목적을 달성하는 방법은 (여러 가지가 아니라) 하나만 제공한다.
의존성은 최소이며 각 의존성을 명확히 정의한다.
API는 명확하며 최소로 줄였다.
언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.
> 
- 데이브도 '가독성'을 강조하지만, 깨끗한 코드는 다른 사람이 고치기 쉽다고 단언한다는 점도 강조한다.
- 읽기 쉬운 코드와 고치기 쉬운 코드는 엄연히 다르다.
- 데이브는 깨끗한 코드를 테스트 케이스와 연관짓는다.
- **테스트 케이스가 없는 코드는 깨끗한 코드가 아니다.**
- 큰 코드보다 작은 코드에 가치를 둠. → 소프트웨어 분야에서는 작을수록 좋다.
- 데이브는 코드가 '문학적'이어야 한다고 말한다. → 인간이 읽기 좋은 코드

### **마이클 페더스**

> 깨끗한 코드의 특징은 많지만 그 중에서도 모두를 아우르는 특징이 하나 있다.
깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다.
고치려고 살펴봐도 딱히 손 댈 곳이 없다.
작성자가 이미 상황을 고려했으므로, 고칠 궁리를 하다보면 언제나 제자리로 돌아온다.
그리고는 누군가 남겨준 코드, 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다.
> 
- 깨끗한 코드는 주의 깊게 작성한 코드다.

### **론 제프리스**

> 간단한 코드는
- 모든 테스트를 통과한다.
- 중복이 없다.
- 시스템 내 모든 설계 아이디어를 표현한다.
- 클래스, 메서드, 함수 등을 최대한 줄인다.
> 
- **같은 작업을 여러 차례 반복한다면 코드가 아이디어를 제대로 표현하지 못한다는 증거**다. → 중복 제거
- 문제의 아이디어를 찾아내 좀 더 명확하게 표현
    - 표현력은 의미 있는 이름을 포함한다.
    - 객체가 여러 기능을 수행한다면 여러 객체로 나눈다.
    - 메서드가 여러 기능을 수행한다면 메서드 추출(Extract Method) 리팩터링 기법을 적용해 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러 개로 나눈다.
- '집합에서 항목 찾기'
    - 어떤 집합에서 특정 항목을 찾아낼 필요가 자주 생긴다.
    - 이런 상황이 발생하면 추상 메서드나 추상 클래스를 만들어 실제 구현을 감싼다.
        - 실제 구현의 경우 지금은 간단하게 재빨리 구현했다가 나중에 필요할 때 바꾸면 된다.
- **결론 : 중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기 → 깨끗한 코드를 만드는 비결**

### **워드 커닝햄**

> 코드를 읽으면서  짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 됨.
코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.
> 
- 깨끗한 코드는 읽으면서 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다.
- 읽으면서 짐작한 대로 돌아가는 코드가 깨끗한 코드다.
- 코드를 단순하게 보이도록 만드는 책임은 우리에게 있다.

---

- 코드를 읽는 시간 대 코드를 짜는 시간 비율이 10 대 1을 훌쩍 넘음
- 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다. →  읽기 쉬운 코드가 매우 중요하다.
- 코드를 읽기 쉽게 만들면 짜기도 쉬워진다.
- 주변 코드를 읽지 않으면 새 코드를 짜지 못한다.
- 급하다면, 서둘러 끝내려면, 쉽게 짜려면, **읽기 쉽게 만들면 된다. → 하지만 어렵다..**

---

### 9. 보이스카우트 규칙

- 잘 짠 코드가 전부는 아니다 → 시간이 지나도 언제나 깨끗하게 유지해야 한다.
- 시간이 지나면서 엉망으로 전락하는 코드가 한둘이 아니다. → 코드의 퇴보를 우리는 적극적으로 막아야 한다.
- 보이스카우트 규칙 : 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.
- 시간이 지날수록 코드가 좋아지는 프로젝트
- 지속적인 개선이야말로 전문가 정신의 본질
